https://www.cs.uic.edu/~s/musings/linkers/

What is a Linker?

Linkers operate on object files among other things. Object files are the
output of a compiler + assembler. The compiler translates some code (C/C++ etc)
into assembly (machine executable fmt). The assembler turns blobs of assembly
into object files... this is where the linker comes in.

In a world where no code is shared anywhere executables are written in assembly
and compilers and linkers don't exist.

In the real world code is reused by packaging useful functions into libraries.
This meant the assembler needed to run on both the library code and the application
code and something needed to combine those pieces of assembly into a single executable.
Assemblers needed to output an 'object file' instead of an executable.

Enter the linker. 'linker' became the name for programs that combine object files
into a single executable.

Linkers became especially important with the advent of shared libraries. Shared
libraries are valuable in systems that run many processes. Before shared libraries
each process would have a large chunk of library code copied into the address
space of each process. In a virtual memory system there can be a single copy of a
library and it can mapped into the address space of each process. The virtual address
of the shared library maps to the same physical memory for all processes

However this means each process must reserve some amount of virtual memory for
each shared library. A further optimization is to move some of the linker's job
to runtime. When a program is started, a 'dynamic linker' runs that links the
executable to the shared libraries.

//////////////////////////////////////////////////////////////////////////////////////

What operations can a linker perform:
Linkers operate on symbols, relocations and contents.

The contents are what memory should look like during the execution of the program.
The linker places symbol and performs relocations to place undefined symbols in
the correct place in the contents. Contents have a size a []byte and a type.
The []byte contains machine code generated by the compiler and assembler. The
contents also contains static variables like constants and initialized variables.

Symbols are names and values. The symbol is a name (ie function name) and the
value is the offset into the contents where that symbol can be found the offset
is roughly the address of the variable, what you get from &<global_variable>.
Symbols can also indicate a reference to a symbol defined in another object file.
This is called an 'undefined' symbol.

How does the linker use symbols: During the linking process symbols are assigned
an address and undefined symbols are 'resolved' by finding a symbol of the same
name.

Relocations are a computation to be performed on the object file's contents. They
typically refer to a symbol and an offset with the contents with an optional extra
instruction called an 'addend'.

Ex: 'set this location in the contents to the value of <symbol> + this addend'

Linkers perform relocation actions during the linking process, often when resolving
an undefined symbol. If the linker fails to resolve a symbol it may throw an error.


Linker workflow:
- read input object files
- determine the length and type of contents
- create a symbol table from object files
- resolve undefined symbols
- assign addresses to all symbols / determine where they will reside in memory
- read the contents and apply relocations
- output executable

//////////////////////////////////////////////////////////////////////////////////////

What is an address space:
An address space is a view of memory where each byte has an address.
Object files are an address space. Each symbol and relocation is referred
to in the contents by its address. The program output by the linker (executable)
is placed in memory and given a virtual address space. The program starts at
the load memory address.

When a program is loaded into memory the dynamic linker will load any shared
libraries into the virtual memory space of that process and perform relocations
so the shared library symbols are in the correct place in the processes memory.
Shared library systems try to minmize the number of relocations required to load
the shared library since those relocations happen at runtime.

Object file formats:
Most object files are organized into sections. Each section holds memory contents.
Sections typically have a name, a type, a size, an address, and an associated
array of data.

Record oriented object files have a serires of records. Records contain some
table of contents info and some data. Records may define symbols, relocations
and sections. Reading a record oriented object file requires reading from the
beginning and processing each record. IEEE-695 and mach-O are record oriented.

Section oriented object files have a section table. Symbols may appear in
a section of the object file defined by the file header or in their own section.
Relocations may be contained in a section or have their own section. Section
oriented files have the that they need not be read serially. Section oriented
files can be processed by reading the section table and reading specific sections.
ELF, COFF, PE, and a.out are section oriented object file formats.

Debug information can be large and is stored in special ways:
a.out stores them as 'stabs' which are special strings in the symbol table.
ELF files create sections with special debug names

//////////////////////////////////////////////////////////////////////////////////////

